# C# Notes
## Basic
### 基本语法

- C # .Net 框架的一部分

- 所有的语句和表达式必须以分号（;）结尾

- 与 Java 不同的是，文件名可以不同于类的名称(而使用命名空间来实现访问)

- *在VS中输入 cw 回车(tab) 即可快速输入 Console.WriteLine();*

  ```c#
  // 示例代码展示
  
  using System;  //用于声明程序中包含 System 命名空间,程序中一般有多个 using 语句
  
  namespace HelloWorldApplicatioin{  //自定义命名空间, 包含了一系列的类
      public class HelloWorld{   // 类名
          public void Main(string[] args){   // Main方法(M大写)
              const string str = "瑠璃璃啊";   // const 即java的final关键字
              Class1 c = new Class1();
              c.printStr(str);
              
              Console.ReadKey(); 
          }
      }
      
      public class Class1{
          public void printStr(String str){
              Console.WriteLine(str);
          }
      }
      
  }
  ```
### 数据类型

- **值类型(基本类型)**

  | 类型    | 描述                                 | 范围                                                    | 默认值 |
  | ------- | ------------------------------------ | ------------------------------------------------------- | ------ |
  | byte    | 8 位无符号整数                       | 0 到 255                                                | 0      |
  | short   | 16 位有符号整数类型                  | -32,768 到 32,767                                       | 0      |
  | int     | 32 位有符号整数类型                  | -2,147,483,648 到 2,147,483,647                         | 0      |
  | long    | 64 位有符号整数类型                  | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0L     |
  | decimal | 128 位精确的十进制值，28-29 有效位数 | (-7.9 x 1028 到 7.9 x 1028)  / 100 到 28                | 0.0M   |
  | float   | 32 位单精度浮点型                    | -3.4 x 1038 到 + 3.4 x 1038                             | 0.0F   |
  | double  | 64 位双精度浮点型                    | (+/-)5.0 x 10-324 到 (+/-)1.7 x 10308                   | 0.0D   |
  | char    | 16 位 Unicode 字符                   | U +0000 到 U +ffff                                      | '\0'   |
  | bool    | 布尔值                               | True 或 False                                           | False  |
  | sbyte   | 8 位有符号整数类型                   | -128 到 127                                             | 0      |
  | uint    | 32 位无符号整数类型                  | 0 到 4,294,967,295                                      | 0      |
  | ulong   | 64 位无符号整数类型                  | 0 到 18,446,744,073,709,551,615                         | 0      |
  | ushort  | 16 位无符号整数类型                  | 0 到 65,535                                             | 0      |

- **引用类型**

  - **Object**类型:

    Object是数据类型的终极基类(同java)

    object 是 System.Object 类的别名(大小写都一样)

    ```c#
    Object == object
    //当一个值类型转换为对象类型时，则被称为 装箱；另一方面，当一个对象类型转换为值类型时，则被称为 拆箱
    ```

  - **dynamic**类型

    存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。

    声明动态类型的语法：

    ```c#
    dynamic <variable_name> = value;  // 类似于auto
    dynamic d = 20;
    ```

    动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。

  - **string**类型

    字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的

    ```c#
    String == string
    ```

    C# string 字符串的前面可以加 @（称作"逐字字符串"）将转义字符（\）当作普通字符对待，比如：

    ```c#
    string str = @"C:\Windows";
    
    string str = "C:\\Windows"; // 等价于上方
    ```

    @ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。

    ```
    string str = @"<script type=""text/javascript"">
        <!--
        -->
    </script>";
    ```

    用户自定义引用类型有：class、interface 或 delegate。

- **指针类型**

  指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。
  
  声明指针类型的语法：
  
  ```c#
  type* identifier;
  //例如
  char* cptr;
  int* iptr;
  ```



### 类型转换

- **隐式类型转换**

  ```c#
  byte b = 10;
  int i = b; // 隐式转换，不需要显式转换
  ```

- **显式类型转换，即强制类型转换。**

  ```c#
  int i = 10;
  byte b = (byte)i; // 显式转换，需要使用强制类型转换符号
  
  int intValue = 123;
  string stringValue = intValue.ToString(); // 将 int 转换为字符串
  ```

  C# 提供了下列内置的类型转换方法：

  | 序号 | 方法 & 描述                                                  |
  | ---- | ------------------------------------------------------------ |
  | 12   | **ToString** 把类型转换为字符串类型。                        |
  | 2    | **ToByte** 把类型转换为字节类型。                            |
  | 7    | **ToInt16** 把类型转换为 16 位整数类型。Convert.ToInt16(num); |
  | 8    | **ToInt32** 把类型转换为 32 位整数类型。                     |
  | 9    | **ToInt64** 把类型转换为 64 位整数类型。                     |
  | 1    | **ToBoolean** 如果可能的话，把类型转换为布尔型。             |
  | 3    | **ToChar** 如果可能的话，把类型转换为单个 Unicode 字符类型。 |
  | 4    | **ToDateTime** 把类型（整数或字符串类型）转换为 日期-时间 结构。 |
  | 5    | **ToDecimal** 把浮点型或整数类型转换为十进制类型。           |
  | 6    | **ToDouble** 把类型转换为双精度浮点型。                      |
  | 10   | **ToSbyte** 把类型转换为有符号字节类型。                     |
  | 11   | **ToSingle** 把类型转换为小浮点数类型。                      |
  | 13   | **ToType** 把类型转换为指定类型。                            |
  | 14   | **ToUInt16** 把类型转换为 16 位无符号整数类型。              |
  | 15   | **ToUInt32** 把类型转换为 32 位无符号整数类型。              |
  | 16   | **ToUInt64** 把类型转换为 64 位无符号整数类型。              |



### 语法补充

- 枚举

  ```c#
  enum <enum_name>
  { 
      enumeration list 
  };
  ```

- 运算符补充

  | 运算符   | 描述                                   | 实例                                                         |
  | -------- | -------------------------------------- | ------------------------------------------------------------ |
  | sizeof() | 返回数据类型的大小。                   | sizeof(int)，将返回 4.                                       |
  | typeof() | 返回 class 的类型。                    | typeof(StreamReader);                                        |
  | &        | 返回变量的地址。                       | &a; 将得到变量的实际地址。                                   |
  | *        | 变量的指针。                           | *a; 将指向一个变量。                                         |
  | ? :      | 条件表达式                             | 如果条件为真 ? 则为 X : 否则为 Y                             |
  | is       | 判断对象是否为某一类型。               | If( Ford is Car)  // 检查 Ford 是否是 Car 类的一个对象。     |
  | as       | 强制转换，即使转换失败也不会抛出异常。 | Object obj = new StringReader("Hello");      StringReader r = obj as StringReader; |

- **方法的引用传值和输出传值**

  | 方式     | 描述                                                         |
  | -------- | ------------------------------------------------------------ |
  | 引用参数 | 这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。(用于改变传递的值) |
  | 输出参数 | 这种方式可以返回多个值。(用于接收要变更的值)                 |

  ```c#
  //使用输出来改变值
  public void change(out int x, out int y) {
      x = 123;
      y = 456;
  }
  
  //使用引用改变|交换值
  public void swap(ref int a, ref int b) {
      a = a ^ b;
      b = a ^ b;
      a = a ^ b;  
  }
  
  //调用
  int a = 1, b = 2, c = 1, d = 1;
  swap(ref a, ref b);
  change(out x, out y);
  ```

- 可空类型

  一个特殊的数据类型，**nullable** 类型（可空类型）

  Nullable< Int32 >，读作"可空的 Int32"，可以被赋值为 -2,147,483,648 到  2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable< bool > 变量可以被赋值为  true 或 false 或 null。

  在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。

  ```c#
  //声明语法
  <data_type> ? <variable_name> = null;
  NUllable<date_type> <varable_name> = new Nullable<int>(null);
  
  int? a = 3;
  double? b = new double?();
  
  //相当于
  Nullable<int> a = 3;
  ```

  合并运算符（ ?? ）

  作用是判断??左边的对象是否为 null，如果不为返回左边，如果为则返回右边

  *相当于三元表达式的简写*

  ```C#
  num2 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34
  //也就是 num2 = num1 == null? 5.34:num1;
  ```

- 可变参数->参数数组

  ```c#
  // public 返回类型 方法名称( params 类型名称[] 数组名称 )
  //示例
  public int AddElements(params int[] arr)
   {
      int sum = 0;
      foreach (int i in arr)
      {
         sum += i;
      }
      return sum;
   }
  ```

- Array类

  类属性

  | 序号 | 属性 & 描述                                                  |
  | ---- | ------------------------------------------------------------ |
  | 1    | **IsFixedSize** 获取一个值，该值指示数组是否带有固定大小。   |
  | 2    | **IsReadOnly** 获取一个值，该值指示数组是否只读。            |
  | 3    | **Length** 获取一个 32 位整数，该值表示所有维度的数组中的元素总数。 |
  | 4    | **LongLength** 获取一个 64 位整数，该值表示所有维度的数组中的元素总数。 |
  | 5    | **Rank** 获取数组的秩（维度）。                              |

  下表列出了 Array 类中一些最常用的方法：

  | 序号 | 方法 & 描述                                                  |
  | ---- | ------------------------------------------------------------ |
  | 1    | **Clear** 根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null。 |
  | 2    | **Copy(Array, Array, Int32)** 从数组的第一个元素开始复制某个范围的元素到另一个数组的第一个元素位置。长度由一个 32 位整数指定。 |
  | 3    | **CopyTo(Array, Int32)** 从当前的一维数组中复制所有的元素到一个指定的一维数组的指定索引位置。索引由一个 32 位整数指定。 |
  | 4    | **GetLength**  获取一个 32 位整数，该值表示指定维度的数组中的元素总数。 |
  | 5    | **GetLongLength** 获取一个 64 位整数，该值表示指定维度的数组中的元素总数。 |
  | 6    | **GetLowerBound** 获取数组中指定维度的下界。                 |
  | 7    | **GetType** 获取当前实例的类型。从对象（Object）继承。       |
  | 8    | **GetUpperBound** 获取数组中指定维度的上界。                 |
  | 9    | **GetValue(Int32)** 获取一维数组中指定位置的值。索引由一个 32 位整数指定。 |
  | 10   | **IndexOf(Array, Object)** 搜索指定的对象，返回整个一维数组中第一次出现的索引。 |
  | 11   | **Reverse(Array)** 逆转整个一维数组中元素的顺序。            |
  | 12   | **SetValue(Object, Int32)** 给一维数组中指定位置的元素设置值。索引由一个 32 位整数指定。 |
  | 13   | **Sort(Array)** 使用数组的每个元素的 IComparable 实现来排序整个一维数组中的元素。 |
  | 14   | **ToString** 返回一个表示当前对象的字符串。从对象（Object）继承。 |

- **结构体struct**

  C# 中的结构有以下特点：

  - 结构可带有方法、字段、索引、属性、运算符方法和事件。
  - 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。
  - 与类不同，结构不能继承其他的结构或类。
  - 结构不能作为其他结构或类的基础结构。
  - 结构可实现一个或多个接口。
  - 结构成员不能指定为 abstract、virtual 或 protected。
  - 当您使用 **New** 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。
  - 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。

  ```c#
  struct Books
  {
     public string title;
     public string author;
     public string subject;
     public int book_id;
  };  
  
  //使用
   Books Book1;        /* 声明 Book1，类型为 Books */
  Book1.title = "C Programming";
  Book1.author = "Nuha Ali";
  Book1.subject = "C Programming Tutorial";
  Book1.book_id = 6495407;
  ```

  类和结构有以下几个基本的不同点：

  **值类型 vs 引用类型：**

  - **结构是值类型（Value Type）：** 结构是值类型，它们在栈上分配内存，而不是在堆上。当将结构实例传递给方法或赋值给另一个变量时，将复制整个结构的内容。
  - **类是引用类型（Reference Type）：** 类是引用类型，它们在堆上分配内存。当将类实例传递给方法或赋值给另一个变量时，实际上是传递引用（内存地址）而不是整个对象的副本。

  **继承：**

  - **结构不能继承：** 结构不能继承其他结构或类，也不能作为其他结构或类的基类。
  - **类支持继承：** 类支持单继承，一个类可以继承另一个类的成员，并且可以实现多个接口。

  **默认构造函数：**

  - **结构不能有无参数的构造函数：** 结构不能包含无参数的构造函数。每个结构都必须有至少一个有参数的构造函数。
  - **类可以有无参数的构造函数：** 类可以包含无参数的构造函数，如果没有提供构造函数，系统会提供默认的无参数构造函数。

  **可空性：**

  - **结构可以是可空的：** 结构可以被声明为可空，即可以赋予 `null` 值。
  - **类默认可为null：** 类的实例默认可以为 `null`，因为它们是引用类型。

  **性能和内存分配：**

  - **结构通常更轻量：** 由于结构是值类型且在栈上分配内存，它们通常比类更轻量，适用于简单的数据表示。
  - **类可能有更多开销：** 由于类是引用类型，可能涉及更多的内存开销和管理。



## OOP

### 修饰符

- 范围比较

  ```c#
  // internal 访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问
  public > protected internal > internal > protected > private
  //其中protected和internal可以连用, 表示符合任意一条都可以访问
  ```

  
